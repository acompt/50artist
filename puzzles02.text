Andrea Compton
9/10/14
30mins
Tyler Lubeck
I did not look at any available solutions.

****************************************************************
3.4 Multiplex

Solution:
sem = semaphore(n)

All threads:
sem.wait()
action
sem.signal()

Explanation:
The semaphore starts at N thus N threads call wait and do thier action.
Once N threads have gone the other threads cause the semaphore to be 
negative and must wait for one of the other threads to finish and signal.
Thus only N threads can do the action at the same time.

*******************************************************************
3.5 Barrier

Solution:
countsem = semaphore(1)
allowcritical = semaphore(0)
n = number of threads
count = 0

All threads:
rendevous
countsem.wait()
count += 1
countsem.signal()
if count == n:
        allowcritical.signal()
else:
        allowcritical.wait()
critical point

Explanation:
The countsem starts at 1 and keeps track of all threads that have
exectued rendevous and updated the counter. It allows each thread to 
update the counter without any other thread having access to the counter.
Thus when all threads have executed rendevous and the counter == n,
the allowcritical semiphore will signal allowing the tread to run its
critical point code. The allowcritical semaphore begins at 0 so it will
become negative if the count is not zero, thus stopping the thread 
until the count becomes n.
